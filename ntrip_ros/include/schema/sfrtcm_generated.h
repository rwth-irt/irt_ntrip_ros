// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SFRTCM_IRT_SFUSION_H_
#define FLATBUFFERS_GENERATED_SFRTCM_IRT_SFUSION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 4,
             "Non-compatible flatbuffers version included");

#include "sfusion_generated.h"

namespace IRT {
namespace SFusion {

struct RTCM3L1E1;
struct RTCM3L1E1Builder;

struct RTCM3L1E1 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RTCM3L1E1Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SF_TIME = 4,
    VT_TOW = 6,
    VT_BASE = 8,
    VT_SVID = 10,
    VT_PSR = 12,
    VT_TYPE = 14,
    VT_CARRIER = 16,
    VT_CN0 = 18,
    VT_LOCKTIME = 20,
    VT_REF_ID = 22
  };
  const IRT::SFusion::SFusionTime *sf_time() const {
    return GetStruct<const IRT::SFusion::SFusionTime *>(VT_SF_TIME);
  }
  double tow() const {
    return GetField<double>(VT_TOW, 0.0);
  }
  const ::flatbuffers::Vector<double> *base() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_BASE);
  }
  const ::flatbuffers::Vector<uint8_t> *svid() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SVID);
  }
  const ::flatbuffers::Vector<double> *psr() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_PSR);
  }
  const ::flatbuffers::Vector<uint8_t> *type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_TYPE);
  }
  const ::flatbuffers::Vector<double> *carrier() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_CARRIER);
  }
  const ::flatbuffers::Vector<double> *cn0() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_CN0);
  }
  const ::flatbuffers::Vector<uint16_t> *locktime() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_LOCKTIME);
  }
  uint16_t ref_id() const {
    return GetField<uint16_t>(VT_REF_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<IRT::SFusion::SFusionTime>(verifier, VT_SF_TIME, 8) &&
           VerifyField<double>(verifier, VT_TOW, 8) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyVector(base()) &&
           VerifyOffset(verifier, VT_SVID) &&
           verifier.VerifyVector(svid()) &&
           VerifyOffset(verifier, VT_PSR) &&
           verifier.VerifyVector(psr()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyVector(type()) &&
           VerifyOffset(verifier, VT_CARRIER) &&
           verifier.VerifyVector(carrier()) &&
           VerifyOffset(verifier, VT_CN0) &&
           verifier.VerifyVector(cn0()) &&
           VerifyOffset(verifier, VT_LOCKTIME) &&
           verifier.VerifyVector(locktime()) &&
           VerifyField<uint16_t>(verifier, VT_REF_ID, 2) &&
           verifier.EndTable();
  }
};

struct RTCM3L1E1Builder {
  typedef RTCM3L1E1 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sf_time(const IRT::SFusion::SFusionTime *sf_time) {
    fbb_.AddStruct(RTCM3L1E1::VT_SF_TIME, sf_time);
  }
  void add_tow(double tow) {
    fbb_.AddElement<double>(RTCM3L1E1::VT_TOW, tow, 0.0);
  }
  void add_base(::flatbuffers::Offset<::flatbuffers::Vector<double>> base) {
    fbb_.AddOffset(RTCM3L1E1::VT_BASE, base);
  }
  void add_svid(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> svid) {
    fbb_.AddOffset(RTCM3L1E1::VT_SVID, svid);
  }
  void add_psr(::flatbuffers::Offset<::flatbuffers::Vector<double>> psr) {
    fbb_.AddOffset(RTCM3L1E1::VT_PSR, psr);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> type) {
    fbb_.AddOffset(RTCM3L1E1::VT_TYPE, type);
  }
  void add_carrier(::flatbuffers::Offset<::flatbuffers::Vector<double>> carrier) {
    fbb_.AddOffset(RTCM3L1E1::VT_CARRIER, carrier);
  }
  void add_cn0(::flatbuffers::Offset<::flatbuffers::Vector<double>> cn0) {
    fbb_.AddOffset(RTCM3L1E1::VT_CN0, cn0);
  }
  void add_locktime(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> locktime) {
    fbb_.AddOffset(RTCM3L1E1::VT_LOCKTIME, locktime);
  }
  void add_ref_id(uint16_t ref_id) {
    fbb_.AddElement<uint16_t>(RTCM3L1E1::VT_REF_ID, ref_id, 0);
  }
  explicit RTCM3L1E1Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RTCM3L1E1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RTCM3L1E1>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RTCM3L1E1> CreateRTCM3L1E1(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const IRT::SFusion::SFusionTime *sf_time = nullptr,
    double tow = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> base = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> svid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> psr = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> carrier = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> cn0 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> locktime = 0,
    uint16_t ref_id = 0) {
  RTCM3L1E1Builder builder_(_fbb);
  builder_.add_tow(tow);
  builder_.add_locktime(locktime);
  builder_.add_cn0(cn0);
  builder_.add_carrier(carrier);
  builder_.add_type(type);
  builder_.add_psr(psr);
  builder_.add_svid(svid);
  builder_.add_base(base);
  builder_.add_sf_time(sf_time);
  builder_.add_ref_id(ref_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RTCM3L1E1> CreateRTCM3L1E1Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const IRT::SFusion::SFusionTime *sf_time = nullptr,
    double tow = 0.0,
    const std::vector<double> *base = nullptr,
    const std::vector<uint8_t> *svid = nullptr,
    const std::vector<double> *psr = nullptr,
    const std::vector<uint8_t> *type = nullptr,
    const std::vector<double> *carrier = nullptr,
    const std::vector<double> *cn0 = nullptr,
    const std::vector<uint16_t> *locktime = nullptr,
    uint16_t ref_id = 0) {
  auto base__ = base ? _fbb.CreateVector<double>(*base) : 0;
  auto svid__ = svid ? _fbb.CreateVector<uint8_t>(*svid) : 0;
  auto psr__ = psr ? _fbb.CreateVector<double>(*psr) : 0;
  auto type__ = type ? _fbb.CreateVector<uint8_t>(*type) : 0;
  auto carrier__ = carrier ? _fbb.CreateVector<double>(*carrier) : 0;
  auto cn0__ = cn0 ? _fbb.CreateVector<double>(*cn0) : 0;
  auto locktime__ = locktime ? _fbb.CreateVector<uint16_t>(*locktime) : 0;
  return IRT::SFusion::CreateRTCM3L1E1(
      _fbb,
      sf_time,
      tow,
      base__,
      svid__,
      psr__,
      type__,
      carrier__,
      cn0__,
      locktime__,
      ref_id);
}

inline const IRT::SFusion::RTCM3L1E1 *GetRTCM3L1E1(const void *buf) {
  return ::flatbuffers::GetRoot<IRT::SFusion::RTCM3L1E1>(buf);
}

inline const IRT::SFusion::RTCM3L1E1 *GetSizePrefixedRTCM3L1E1(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<IRT::SFusion::RTCM3L1E1>(buf);
}

inline bool VerifyRTCM3L1E1Buffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<IRT::SFusion::RTCM3L1E1>(nullptr);
}

inline bool VerifySizePrefixedRTCM3L1E1Buffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<IRT::SFusion::RTCM3L1E1>(nullptr);
}

inline void FinishRTCM3L1E1Buffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<IRT::SFusion::RTCM3L1E1> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRTCM3L1E1Buffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<IRT::SFusion::RTCM3L1E1> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace SFusion
}  // namespace IRT

#endif  // FLATBUFFERS_GENERATED_SFRTCM_IRT_SFUSION_H_
